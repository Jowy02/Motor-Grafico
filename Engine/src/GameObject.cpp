#include "GameObject.h"
#include "Application.h"
#include "Camera.h"
#include "Texture.h"
#include <iostream>
#include <cstring> 
#include "Mesh.h"
#include "Menus.h"
#include "Scene.h"

GameObject::GameObject(const std::string& path)
{
    myMesh = new ComponentMesh(this);
    myTransform = new ComponentTransform(this);

    // Distinguish between a loaded model and a geometry generated by our library.
    if (path != "NULL" && path != "Imported") loadModel(path);
    else 
    {
        myTransform->position = { 0,0,0 };
        myTransform->rotation = { 0,0,0 };
        myTransform->scale = { 1,1,1 };

        myTransform->worldPosition = { 0,0,0 };
        myTransform->worldRotation = { 0,0,0 };
        myTransform->worldScale = { 1,1,1 };

        myTransform->minAABB = { -1,-1,-1 };
        myTransform->maxAABB = { 1,1,1 };
    }
}
void GameObject::ApplTexture(Texture* tex, std::string path)
{
    myMesh->mesh.texture = tex;
    actualTexture = tex;
    texturePath = path;

    if (tex != nullptr)
    {
        hasTransparency = tex->hasAlpha;
    }
    else
    {
        hasTransparency = false;
    }
}
// Draw all meshes of the model
void GameObject::Draw()
{
    if (isHidden) return;

    GLuint shaderProgram = Application::GetInstance().render->shaderProgram;

    if (hasTransparency) {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glDepthMask(GL_FALSE);
    }
        
    else {
        glDisable(GL_BLEND);
        glDepthMask(GL_TRUE);
    }

    // Send the transformation matrix to the shader
    GLint modelLoc = glGetUniformLocation(shaderProgram, "model_matrix");
    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(myTransform->transformMatrix));
    
    if (myMesh->mesh.texture)
    {
        myMesh->mesh.texture->texUnit(shaderProgram, "tex0", 0);
        myMesh->mesh.texture->Bind();
        GLint useTexLoc = glGetUniformLocation(shaderProgram, "useTexture");

        glUniform1i(useTexLoc, 1);
    }
    else
    {
        GLint useTexLoc = glGetUniformLocation(shaderProgram, "useTexture");
        glUniform1i(useTexLoc, 0);
    }
 
    glm::vec4 overrideColorVec(0.0f, 0.0f, 0.0f, 0.0f); // default: no override

    // Draw all meshes
    glBindVertexArray(myMesh->mesh.VAO);

    if (name != "Grid") glDrawElements(GL_TRIANGLES, myMesh->mesh.indexCount, GL_UNSIGNED_INT, 0);
    else glDrawElements(GL_LINES, myMesh->mesh.indexCount, GL_UNSIGNED_INT, 0);

    glBindVertexArray(0);

    if (myMesh->mesh.texture)
        myMesh->mesh.texture->Unbind();

    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
}

void GameObject::UpdateTransform()
{
    for (int x = 0; x < childrenID.size(); x++) 
        Application::GetInstance().scene.get()->models[childrenID[x]].UpdateTransform();

    myTransform->GenerateLocalMatrix();

    if (isChild)
    {
        myTransform->transformMatrix = Application::GetInstance().scene->models[ParentID].myTransform->transformMatrix * myTransform->localMatrix;
        parentTransform = false;
    }
    else
    {
        myTransform->transformMatrix = myTransform->localMatrix;
    }

    float translation[3], rotationDeg[3], scaleArr[3];
    ImGuizmo::DecomposeMatrixToComponents(glm::value_ptr(myTransform->transformMatrix), translation, rotationDeg, scaleArr);
    myTransform->BoundingBox(translation, rotationDeg, scaleArr);

    // Actualiza posiciones mundiales
   
    myMesh->mesh.positionsWorld.resize(myMesh->mesh.positionsLocal.size());
    for (size_t i = 0; i < myMesh->mesh.positionsLocal.size(); ++i) {
        glm::vec4 p = myTransform->transformMatrix * glm::vec4(myMesh->mesh.positionsLocal[i], 1.0f);
        myMesh->mesh.positionsWorld[i] = glm::vec3(p);
    }
    // Actualiza AABB mundo usando los bounds locales (funci�n ya existente)
    myTransform->UpdateAABB();
}

// Load a model using Assimp
void GameObject::loadModel(const std::string& path)
{

    directory = path.substr(0, path.find_last_of('/'));

    name = path.substr(path.find_last_of("/\\") + 1);
    name = name.substr(0, name.find_last_of('.'));

    modelPath = "../Library/Meshes/" + name + ".txt";

    //processNode(scene->mRootNode, scene);
    Application::GetInstance().mesh.get()->loadModel(path, this);

    //processOthers(scene);
    myTransform->center = (myTransform->minAABB + myTransform->maxAABB) * 0.5f;
    myTransform->size = myTransform->maxAABB - myTransform->minAABB;

    myTransform->localMinAABB = myTransform->minAABB;
    myTransform->localMaxAABB = myTransform->maxAABB;

    myTransform->position = { 0,0,0 };
    myTransform->rotation = { 0,0,0 };
    myTransform->scale = { 1,1,1 };

    if (!Application::GetInstance().scene->octreeRoot) {
        Application::GetInstance().scene->BuildOctree();
    }
    else {
        OctreeNode* root = Application::GetInstance().scene->octreeRoot.get();
        root->Insert(&Application::GetInstance().scene->models.back());
    }
    blackWhite = new Texture("../Images/BlancoNegro.png", GL_TEXTURE_2D, GL_TEXTURE0, GL_RGBA, GL_UNSIGNED_BYTE);
    
    UpdateTransform();
    myTransform->UpdateAABB();

}
// Switch the model's texture (BlackWhite or NormalMap)
void GameObject::switchTexture(bool checker, std::string type)
{
    Texture* tempTex;
    if (type == "BlackWhite")
    {
        if (checker) tempTex = blackWhite;
        else tempTex = actualTexture;
    }
    if (type == "Hide")
    {
        if (checker) tempTex = noTexture;
        else tempTex = actualTexture;
    }
    myMesh->mesh.texture = tempTex;
}

// Get the model matrix
glm::mat4 GameObject::GetModelMatrix() const {
    return  myTransform->transformMatrix;
}
void GameObject::SetChild(GameObject* child)
{
    if (child->ParentID == modelId)
        return;
    for (int x = 0; x < child->childrenID.size(); x++)
    {
        if (child->childrenID[x] == modelId) return;
    }

    if (child->isChild) {
        Application::GetInstance().scene->models[child->ParentID].eraseChild(child->modelId);
    }

    childrenID.push_back(child->modelId);
    child->isChild = true;
    child->ParentID = modelId;

    child->UpdateTransform();
}
void  GameObject::eraseChild(int childId)
{
    childrenID.erase(std::remove(childrenID.begin(), childrenID.end(), childId),childrenID.end());
}

void GameObject::CleanUpChilds()
{
    // Hacer copia de IDs para iterar sin invalidar
    std::vector<int> childrenCopy = childrenID;

    for (int childId : childrenCopy)
    {
        if (childId < 0 || childId >= Application::GetInstance().scene->models.size())
            continue;

        GameObject& child = Application::GetInstance().scene->models[childId];

        // Recursivamente limpiar hijos
        child.CleanUpChilds();

        // Limpiar buffers y texturas
        child.CleanUp();
    }

    childrenID.clear();
}

void GameObject::SaveInitialState() {
    initial_position = myTransform->position;
    initial_rotation = myTransform->rotation;
    initial_scale = myTransform->scale;
    initial_isHidden = isHidden;
    initial_texturePath = texturePath;
    created_in_play = false;
    initial_modelPath = modelPath;
    initial_ParentID = ParentID;
}

void GameObject::LoadInitialState() {
    myTransform->position = initial_position;
    myTransform->rotation = initial_rotation;
    myTransform->scale = initial_scale;
    isHidden = initial_isHidden;
    modelPath = initial_modelPath;
    texturePath = initial_texturePath;
    UpdateTransform();
}

glm::vec3 GameObject::GetInitialPosition() const
{
    return initial_position;
}

glm::vec3 GameObject::GetInitialRotation() const
{
    return initial_rotation;
}

glm::vec3 GameObject::GetInitialScale() const
{
    return initial_scale;
}

std::string GameObject::GetInitialTexturePath() const
{
    return initial_texturePath;
}

bool GameObject::GetInitialIsHidden() const
{
    return initial_isHidden;
}

int GameObject::GetInitialParentID() const
{
    return initial_ParentID;
}

void GameObject::SetInitialParentID(int id)
{
    initial_ParentID = id;
}

void GameObject::CleanUp()
{
    if (myMesh->mesh.VAO != 0)
        glDeleteVertexArrays(1, &myMesh->mesh.VAO);
    if (myMesh->mesh.VBO != 0)
        glDeleteBuffers(1, &myMesh->mesh.VBO);
    if (myMesh->mesh.EBO != 0)
        glDeleteBuffers(1, &myMesh->mesh.EBO);
    if (myMesh->mesh.texture)
        delete myMesh->mesh.texture;
    if (blackWhite)
        delete blackWhite;

    myMesh->mesh.VAO = 0;
    myMesh->mesh.VBO = 0;
    myMesh->mesh.EBO = 0;

    actualTexture = nullptr;
    blackWhite = nullptr;
}
