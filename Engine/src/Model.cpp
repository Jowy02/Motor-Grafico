#include "Model.h"
#include "Application.h"
#include "Camera.h"
#include "Texture.h"
#include <iostream>
#include <cstring> 
#include "Menus.h"
#include "Scene.h"
#include "OctreeNode.h" 

Model::Model(const std::string& path)
{
    // Distinguish between a loaded model and a geometry generated by our library.
    if (path != "NULL" && path != "Imported") loadModel(path);
    else 
    {
        position = { 0,0,0 };
        rotation = { 0,0,0 };
        scale = { 1,1,1 };

        worldPosition = { 0,0,0 };
        worldRotation = { 0,0,0 };
        worldScale = { 1,1,1 };

        minAABB = { -1,-1,-1 };
        maxAABB = { 1,1,1 };
        //UpdateTransform();
    }
}
void Model::ApplTexture(Texture* tex, std::string path)
{
    Mmesh.texture = tex;
    actualTexture = tex;
    texturePath = path;
    hasTransparency = tex->hasAlpha;
}
// Draw all meshes of the model
void Model::Draw()
{
    if (isHidden) return;
   
    GLuint shaderProgram = Application::GetInstance().render->shaderProgram;

    if (hasTransparency) {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glDepthMask(GL_FALSE);
    }
        
    else {
        glDisable(GL_BLEND);
        glDepthMask(GL_TRUE);
    }

    // Send the transformation matrix to the shader
    GLint modelLoc = glGetUniformLocation(shaderProgram, "model_matrix");
    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(transformMatrix));
    
    if (Mmesh.texture)
    {
        Mmesh.texture->texUnit(shaderProgram, "tex0", 0);
        Mmesh.texture->Bind();
        GLint useTexLoc = glGetUniformLocation(shaderProgram, "useTexture");
        glUniform1i(useTexLoc, 1);
    }
    else
    {
        GLint useTexLoc = glGetUniformLocation(shaderProgram, "useTexture");
        glUniform1i(useTexLoc, 0);
    }

    // Draw all meshes
    glBindVertexArray(Mmesh.VAO);

    if (name != "Grid") glDrawElements(GL_TRIANGLES, Mmesh.indexCount, GL_UNSIGNED_INT, 0);
    else glDrawElements(GL_LINES, Mmesh.indexCount, GL_UNSIGNED_INT, 0);

    glBindVertexArray(0);

    if (Mmesh.texture)
        Mmesh.texture->Unbind();

    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
    

}

void Model::UpdateAABB()
{
    glm::vec3 worldMin(std::numeric_limits<float>::max());
    glm::vec3 worldMax(std::numeric_limits<float>::lowest());

    for (int i = 0; i < 8; ++i)
    {
        glm::vec3 corner(
            (i & 1) ? localMaxAABB.x : localMinAABB.x,
            (i & 2) ? localMaxAABB.y : localMinAABB.y,
            (i & 4) ? localMaxAABB.z : localMinAABB.z
        );

        glm::vec4 transformed = transformMatrix * glm::vec4(corner, 1.0f);
        glm::vec3 p = glm::vec3(transformed);

        worldMin = glm::min(worldMin, p);
        worldMax = glm::max(worldMax, p);
    }

    minAABB = worldMin;
    maxAABB = worldMax;
    center = (worldMin + worldMax) * 0.5f;
    size = worldMax - worldMin;
}

void Model::UpdateTransform()
{
    for (int x = 0; x < childrenID.size(); x++) 
        Application::GetInstance().scene.get()->models[childrenID[x]].UpdateTransform();

    localMatrix = glm::mat4(1.0f);
    localMatrix = glm::translate(localMatrix, position);
    localMatrix = glm::rotate(localMatrix, glm::radians(rotation.z), glm::vec3(0, 0, 1));
    localMatrix = glm::rotate(localMatrix, glm::radians(rotation.y), glm::vec3(0, 1, 0));
    localMatrix = glm::rotate(localMatrix, glm::radians(rotation.x), glm::vec3(1, 0, 0));
    localMatrix = glm::scale(localMatrix, scale);

    if (isChild)
    {
        transformMatrix = Application::GetInstance().scene->models[ParentID].transformMatrix * localMatrix;
        parentTransform = false;
    }
    else
    {
        transformMatrix = localMatrix;
    }

    float translation[3], rotationDeg[3], scaleArr[3];
    ImGuizmo::DecomposeMatrixToComponents(glm::value_ptr(transformMatrix), translation, rotationDeg, scaleArr);

    worldPosition = glm::vec3(translation[0], translation[1], translation[2]);

    worldRotation = glm::vec3(rotationDeg[0], rotationDeg[1], rotationDeg[2]);

    worldScale = glm::vec3(scaleArr[0], scaleArr[1], scaleArr[2]);

    // Usa los bounds LOCALES para calcular la caja en mundo
    glm::vec3 corners[8] =
    {
        {localMinAABB.x, localMinAABB.y, localMinAABB.z},
        {localMinAABB.x, localMinAABB.y, localMaxAABB.z},
        {localMinAABB.x, localMaxAABB.y, localMinAABB.z},
        {localMinAABB.x, localMaxAABB.y, localMaxAABB.z},
        {localMaxAABB.x, localMinAABB.y, localMinAABB.z},
        {localMaxAABB.x, localMinAABB.y, localMaxAABB.z},
        {localMaxAABB.x, localMaxAABB.y, localMinAABB.z},
        {localMaxAABB.x, localMaxAABB.y, localMaxAABB.z},
    };

    glm::vec3 newMin(FLT_MAX);
    glm::vec3 newMax(-FLT_MAX);

    for (int i = 0; i < 8; ++i)
    {
        glm::vec4 transformed = transformMatrix * glm::vec4(corners[i], 1.0f);
        glm::vec3 p = glm::vec3(transformed);
        newMin = glm::min(newMin, p);
        newMax = glm::max(newMax, p);
    }

    center = (newMin + newMax) * 0.5f;
    size = newMax - newMin;

    // Actualiza posiciones mundiales
   
    Mmesh.positionsWorld.resize(Mmesh.positionsLocal.size());
    for (size_t i = 0; i < Mmesh.positionsLocal.size(); ++i) {
        glm::vec4 p = transformMatrix * glm::vec4(Mmesh.positionsLocal[i], 1.0f);
        Mmesh.positionsWorld[i] = glm::vec3(p);
    }
    // Actualiza AABB mundo usando los bounds locales (funci�n ya existente)
    UpdateAABB();
}

// Load a model using Assimp
void Model::loadModel(const std::string& path)
{
    modelPath = path;

    Assimp::Importer importer;
    const aiScene* scene = importer.ReadFile(path,
        aiProcess_Triangulate |
        aiProcess_FlipUVs |
        aiProcess_CalcTangentSpace |
        aiProcess_GenNormals
    );

    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)
    {
        std::cerr << "ERROR::ASSIMP::" << importer.GetErrorString() << std::endl;
        Application::GetInstance().menus->LogToConsole(std::string("ERROR: FBX load failed: ") + path);
        Application::GetInstance().menus->LogToConsole(std::string("ERROR: Assimp load failed: ") + importer.GetErrorString());
        return;
    }
    else 
    {
        Application::GetInstance().menus->LogToConsole("Loaded FBX: " + path);
        Application::GetInstance().menus->LogToConsole("ASSIMP initialized");
    }

    directory = path.substr(0, path.find_last_of('/'));

    name = path.substr(path.find_last_of("/\\") + 1);
    name = name.substr(0, name.find_last_of('.'));

    processNode(scene->mRootNode, scene);
    modelId = Application::GetInstance().scene.get()->models.size() + otherMesh.size();
    processOthers(scene);
    center = (minAABB + maxAABB) * 0.5f;
    size = maxAABB - minAABB;

    position = { 0,0,0 };
    rotation = { 0,0,0 };
    scale = { 1,1,1 };

    UpdateTransform();
    if (Application::GetInstance().scene->octreeRoot) {
        OctreeNode* root = Application::GetInstance().scene->octreeRoot.get();
        root->Insert(&Application::GetInstance().scene->models.back());
    }
    blackWhite = new Texture("../Images/BlancoNegro.png", GL_TEXTURE_2D, GL_TEXTURE0, GL_RGBA, GL_UNSIGNED_BYTE);
}
void Model::processOthers(const aiScene* scene)
{
    for (auto& mesh : otherMesh)
    {
        Model newModel("Imported");

        newModel.processMesh(mesh, scene);
        newModel.name = mesh->mName.C_Str();
        newModel.modelId = Application::GetInstance().scene->models.size();
        newModel.center = (minAABB + maxAABB) * 0.5f;
        newModel.size = maxAABB - minAABB;
        newModel.componentID = modelId;

        newModel.position = { 0,0,0 };
        newModel.rotation = { 0,0,0 };
        newModel.scale = { 1,1,1 };

        Application::GetInstance().scene->models.push_back(std::move(newModel));
        Application::GetInstance().scene->models.back().UpdateTransform();

    }
}
// Process all meshes in a node
void Model::processNode(aiNode* node, const aiScene* scene)
{
    for (unsigned int i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];

        if (objNum == 0)
        {
            processMesh(mesh, scene);
            name = mesh->mName.C_Str();
        }
        else
        {
            otherMesh.push_back(mesh);
            haveComponents = true;
        }
        objNum++;
    }

    // Recursively process child nodes
    for (unsigned int i = 0; i < node->mNumChildren; i++)
    {
        processNode(node->mChildren[i], scene);
    }
}

// Convert an aiMesh from Assimp into a ModelMesh with VAO/VBO/EBO
void Model::processMesh(aiMesh* mesh, const aiScene* scene)
{
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    ModelMesh newMesh;

    minAABB = glm::vec3(FLT_MAX);
    maxAABB = glm::vec3(-FLT_MAX);

    Mmesh.positionsLocal.clear();
    Mmesh.indices.clear();
    
    // Extract vertices: position, normal, and UV coordinates
    for (unsigned int i = 0; i < mesh->mNumVertices; i++)
    {
        glm::vec3 vertex(mesh->mVertices[i].x,
            mesh->mVertices[i].y,
            mesh->mVertices[i].z);

        minAABB = glm::min(minAABB, vertex);
        maxAABB = glm::max(maxAABB, vertex);

        Mmesh.positionsLocal.push_back(vertex);

        // Position
        vertices.push_back(vertex.x);
        vertices.push_back(vertex.y);
        vertices.push_back(vertex.z);

        // Normal (solo si existen)
        if (mesh->HasNormals()) {
            vertices.push_back(mesh->mNormals[i].x);
            vertices.push_back(mesh->mNormals[i].y);
            vertices.push_back(mesh->mNormals[i].z);
        }
        else {
            vertices.push_back(0.0f);
            vertices.push_back(0.0f);
            vertices.push_back(0.0f);
        }

        // Texture UV
        if (mesh->HasTextureCoords(0)) {
            vertices.push_back(mesh->mTextureCoords[0][i].x);
            vertices.push_back(mesh->mTextureCoords[0][i].y);
        }
        else {
            vertices.push_back(0.0f);
            vertices.push_back(0.0f);
        }
    }


    localMinAABB = minAABB;
    localMaxAABB = maxAABB;

    // Extract tangents if available
    if (mesh->mTangents != nullptr)
    {
        hasTangents = true;
        tangents.clear();
        for (unsigned int i = 0; i < mesh->mNumVertices; i++)
        {
            tangents.push_back(glm::vec3(mesh->mTangents[i].x,
                mesh->mTangents[i].y,
                mesh->mTangents[i].z));
        }
    }

    // Extract bitangents if available
    if (mesh->mBitangents != nullptr) {
        hasBitangents = true;
        bitangents.clear();
        for (unsigned int i = 0; i < mesh->mNumVertices; i++) {
            bitangents.push_back(glm::vec3(mesh->mBitangents[i].x,
                mesh->mBitangents[i].y,
                mesh->mBitangents[i].z));
        }
    }

    // Extract indices
    for (unsigned int i = 0; i < mesh->mNumFaces; i++) {
        aiFace face = mesh->mFaces[i];
        if (face.mNumIndices == 3) { // asegurarse de que es triángulo
            for (unsigned int j = 0; j < 3; j++) {
                indices.push_back(face.mIndices[j]);
                Mmesh.indices.push_back(face.mIndices[j]);
            }
        }
    }

    
    // Draw vertex and face normals for debugging
    VertexNormalmesh = Application::GetInstance().render.get()->DrawVertexNormalsFromMesh(vertices.data(), vertices.size(), tangents, bitangents, {}, vertexNormalLines);
    Normalmesh = Application::GetInstance().render.get()->DrawFaceNormals(vertices.data(), indices.data(), indices.size(), normalLines);

    // Create OpenGL buffers
    glGenVertexArrays(1, &Mmesh.VAO);
    glGenBuffers(1, &Mmesh.VBO);
    glGenBuffers(1, &Mmesh.EBO);

    glBindVertexArray(Mmesh.VAO);

    glBindBuffer(GL_ARRAY_BUFFER, Mmesh.VBO);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float), vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, Mmesh.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

    // Position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // Normal attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // Texture attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);

    //// Alpha
    //glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, 9 * sizeof(float), (void*)(8 * sizeof(float)));
    //glEnableVertexAttribArray(3);

    glBindVertexArray(0);

    Mmesh.indexCount = indices.size();

    // Load texture from material if available
    if (mesh->mMaterialIndex >= 0)
    {
        aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
        aiString path;
        if (material->GetTexture(aiTextureType_DIFFUSE, 0, &path) == AI_SUCCESS)
        {
            std::string filename = std::string(path.C_Str());

            // Normalize backslashes
            std::replace(filename.begin(), filename.end(), '\\', '/');

            // If the texture path is not absolute, prepend the model directory
            if (filename[0] != '/' && !(filename.length() > 1 && filename[1] == ':'))
                filename = directory + "/" + filename;

            std::cout << "Loading texture from material: " << filename << std::endl;

            Mmesh.texture = new Texture(filename.c_str(), GL_TEXTURE_2D, GL_TEXTURE0, GL_RGBA, GL_UNSIGNED_BYTE);
          
            if (Mmesh.texture)
                hasTransparency = Mmesh.texture->hasAlpha;

        }
        else
        {
            std::cout << "No diffuse texture found in the material." << std::endl;
            Mmesh.texture = nullptr;
            hasTransparency = false;
        }
    }
}

// Switch the model's texture (BlackWhite or NormalMap)
void Model::switchTexture(bool checker, std::string type)
{
    Texture* tempTex;
    if (type == "BlackWhite")
    {
        if (checker) tempTex = blackWhite;
        else tempTex = actualTexture;
    }
    if (type == "Hide")
    {
        if (checker) tempTex = noTexture;
        else tempTex = actualTexture;
    }
    Mmesh.texture = tempTex;
}

// Get the model matrix
glm::mat4 Model::GetModelMatrix() const {
    return transformMatrix;
}
void Model::SetChild(Model* child) 
{
    if (child->ParentID == modelId)
        return;
    for (int x = 0; x < child->childrenID.size(); x++)
    {
        if (child->childrenID[x] == modelId) return;
    }

    if (child->isChild) {
        Application::GetInstance().scene->models[child->ParentID].eraseChild(child->modelId);
    }

    childrenID.push_back(child->modelId);
    child->isChild = true;
    child->ParentID = modelId;

    child->UpdateTransform();
}
void  Model::eraseChild(int childId)
{
    childrenID.erase(std::remove(childrenID.begin(), childrenID.end(), childId),childrenID.end());
}
// Cleanup all OpenGL buffers and textures
void  Model::CleanUpChilds()
{
    auto childCopy = childrenID; // copia segura
    for (int childId : childCopy)
    {
        // Solo borrar si realmente sigue siendo hijo tuyo
        if (Application::GetInstance().scene->models[childId].ParentID == modelId)
        {
            Application::GetInstance().scene->models[childId].CleanUpChilds();

            // borrar del vector childrenID
            eraseChild(childId);

            // borrar del sceneModels
            auto& sceneModels = Application::GetInstance().scene->models;
            sceneModels.erase(
                std::remove_if(sceneModels.begin(), sceneModels.end(),
                    [&](const Model& m) { return m.modelId == childId; }),
                sceneModels.end()
            );
        }
    }   
}
void Model::CleanUp()
{
    if (Mmesh.VAO != 0)
        glDeleteVertexArrays(1, &Mmesh.VAO);
    if (Mmesh.VBO != 0)
        glDeleteBuffers(1, &Mmesh.VBO);
    if (Mmesh.EBO != 0)
        glDeleteBuffers(1, &Mmesh.EBO);
    if (Mmesh.texture)
        delete Mmesh.texture;
    if (blackWhite)
        delete blackWhite;

    Mmesh.VAO = 0;
    Mmesh.VBO = 0;
    Mmesh.EBO = 0;

    Mmesh.texture = nullptr;
    actualTexture = nullptr;
    blackWhite = nullptr;
}